
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>day18 | Hexo</title>
        <meta name="author" content="John Doe" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202207200831813.jpeg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/myblog.github.io/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/myblog.github.io/js/lib/highlight.js"></script>



<script src="/myblog.github.io/js/lib/preview.js"></script>









<link rel="stylesheet" href="/myblog.github.io/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/myblog.github.io/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/myblog.github.io/">
            <span>HEXO</span>
        </a>
        
        <a href="/myblog.github.io/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/myblog.github.io/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/myblog.github.io/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/myblog.github.io/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/myblog.github.io/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;HEXO</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/myblog.github.io/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/myblog.github.io/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/myblog.github.io/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/myblog.github.io/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/myblog.github.io/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>day18</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/22
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/myblog.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="color: #03a9f4">面试题</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h2><ul>
<li><p>是一种基于token的认证授权机制</p>
</li>
<li><p>是一种规范化后的JSON结构的token </p>
</li>
<li><p>是目前最流行的跨域认证解决方案</p>
</li>
</ul>
<p>token包含了身份验证所需的所有信息，因此服务端就不需要存储Session信息，符合RESTFUL的<strong>无状态原则</strong></p>
<blockquote>
<p>无状态原则：</p>
<ul>
<li>每个web请求之间是独立的</li>
<li>客户端发送的请求必须包含能够让服务器理解的全部信息，包含请求的状态信息</li>
<li>使得一个客户端的web请求能够被所有可用的服务端应答</li>
</ul>
<p>优点：让RESTful在分布式系统中得到了广泛的应用，它改善了分布式系统的可见性、可靠性以及可伸缩性，同时有效的降低了Client与Server之间的交互延迟。无状态的请求有利于实现负载均衡以及容错处理</p>
</blockquote>
<p>JWT由三部分组成</p>
<ul>
<li>Header<ul>
<li>Type:令牌类型</li>
<li>Algorithm:签名算法</li>
<li>进行Base64编码,成为JWT的第一部分</li>
</ul>
</li>
<li>Payload<ul>
<li>存放Claims,包含JWT的相关信息</li>
<li>默认不加密,所以不能存放隐私信息</li>
<li>进行Base64编码,成为JWT的第二部分</li>
</ul>
</li>
<li>Signature <ul>
<li>对前两部分的签名,防止token被篡改</li>
<li>Header+Payload+服务端的密钥 &#x3D; Signature</li>
</ul>
</li>
</ul>
<p>最后的出JWT是一串以<code>  .</code> 分割为三部分的字符串</p>
<h2 id="如何基于JWT实现身份验证"><a href="#如何基于JWT实现身份验证" class="headerlink" title="如何基于JWT实现身份验证"></a>如何基于JWT实现身份验证</h2><p>服务端通过Header,Payload和密钥创建token,并将 token发送给客户端,客户端将token存放在本地(Cookie或localStorage),之后 用户每次请求都将携token</p>
<p>具体实现流程</p>
<ul>
<li>用户向服务端发送用户名,密码,验证码等信息用于登录系统</li>
<li>如果账号密码正确,服务端基于Header,Payload和密钥创建token并返回 给客户端</li>
<li>客户端接收token并存放到本地,并且在每次请求时都在Header中携带这个token</li>
<li>服务端检查token并从中获取用户信息</li>
</ul>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208281625918.png" alt="图片"></p>
<ol>
<li>建议将 <code>Token</code> 存放在 localStorage 中，放在 Cookie 中会有 CSRF 风险。</li>
<li>请求服务端并携带 Token 的常见做法是将 <code>Token</code> 放在 HTTP Header 的 <code>Authorization</code> 字段中（<code>Authorization: Bearer Token</code>）</li>
</ol>
<h2 id="如何防止token被篡改"><a href="#如何防止token被篡改" class="headerlink" title="如何防止token被篡改"></a>如何防止token被篡改</h2><p>服务端拿到token后或解析出Header、Payload 以及 Signature ,然后根据Header、Payload 重新生成一个Signature 与token中的Signature 进行比对,如果一样则表示token没有被修改.</p>
<p><strong>注意:前提是在服务端的密钥没被泄露的前提下</strong></p>
<h2 id="如何加强JWT的安全性"><a href="#如何加强JWT的安全性" class="headerlink" title="如何加强JWT的安全性"></a>如何加强JWT的安全性</h2><ol>
<li>使用安全系数高的加密算法。</li>
<li>使用成熟的开源库，没必要造轮子。</li>
<li>Token 存放在 localStorage 中而不是 Cookie 中，避免 CSRF 风险。</li>
<li>一定不要将隐私信息存放在 Payload 当中。</li>
<li>密钥一定保管好，一定不要泄露出去。JWT 安全的核心在于签名，签名安全的核心在密钥。</li>
<li>Payload 要加入 <code>exp</code> （JWT 的过期时间），永久有效的 JWT 不合理。并且，JWT 的过期时间不易过长</li>
</ol>
<h1 id="HTTP协议1-x版本和HTTP协议2-x版本的区别是什么？"><a href="#HTTP协议1-x版本和HTTP协议2-x版本的区别是什么？" class="headerlink" title="HTTP协议1.x版本和HTTP协议2.x版本的区别是什么？"></a>HTTP协议1.x版本和HTTP协议2.x版本的区别是什么？</h1><p>HTTP1.x和HTTP2.0主要的区别主要HTTP2.0使用了二进制的数据传输方式、多路复用机制、头部缓存和服务器推送特点,</p>
<p>具体而言:</p>
<ul>
<li>二进制格式（Binary Format）：HTTP1.x的解析是基于文本，但是基于文本协议的格式解析存在天然缺陷。文本的表现形式应该具有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 </li>
<li>多路复用（MultiPlexing）：连接共享，每一个请求都是是用作连接共享机制的。一个请求对应一个id，这样一个连接上可以有多个请求，每个连接的请求可以随机的混杂在一起，接收方可以根据请求的 id将请求再归属到各自不同的服务端请求里面。 </li>
<li>头部压缩：HTTP1.x的头部带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的头部大小，通讯双方各自缓存一份头部表，既避免了重复头部的传输，又减小了需要传输的大小。 </li>
<li>服务端推送（server push）：如果请求了index.html文件，服务器端会主动将它的依赖文件一起返回。</li>
</ul>
<h1 id="说一说HashMap的扩容机制"><a href="#说一说HashMap的扩容机制" class="headerlink" title="说一说HashMap的扩容机制"></a>说一说HashMap的扩容机制</h1><p>向HashMap中添加数据时,在以下三种情况中会发生扩容</p>
<ul>
<li><p>数组为空时,会触发首次扩容</p>
</li>
<li><p>将元素接入链表后,链表长度为8且数组长度小于64</p>
</li>
<li><p>添加数据后,数组元素超过阈值(阈值&#x3D; 容量 x 负载因子(0.75)),即比例超过0.75,则扩容</p>
</li>
</ul>
<p>每次扩容是将原容量翻倍,然后再将旧数组中的数组迁移到新数组里。由于HashMap中数组的容量为2^N，所以可以用位移运算计算新容量，效率很高。</p>
<h1 id="内存溢出问题该如何解决"><a href="#内存溢出问题该如何解决" class="headerlink" title="内存溢出问题该如何解决"></a>内存溢出问题该如何解决</h1><ul>
<li>调整JVM启动参数,为其分配更多的内存</li>
<li>检查错误日志,查看OOM错误前是否存在其他异常或错误</li>
<li>对代码进行走查和分析找出可能导致内存溢出的地方</li>
<li>使用内存查看工具动态查看内存的使用情况</li>
</ul>
<h1 id="说一说zset类型的底层数据结构"><a href="#说一说zset类型的底层数据结构" class="headerlink" title="说一说zset类型的底层数据结构"></a>说一说zset类型的底层数据结构</h1><p>zset底层使用了ziplist和skiplist,在同时满足有序集合保存的元素数量小于128个且元素的大小小于64个字节时使用ziplist,其他情况使用skiplist.压缩列表是Redis为了节约内存而开发的.</p>
<h1 id="Redis的5种基本数据结构"><a href="#Redis的5种基本数据结构" class="headerlink" title="Redis的5种基本数据结构"></a>Redis的5种基本数据结构</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>一种安全的二进制的数据结构,可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SET key value</td>
<td align="left">设置指定 key 的值</td>
</tr>
<tr>
<td align="left">SETNX key value</td>
<td align="left">只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td align="left">GET key</td>
<td align="left">获取指定 key 的值</td>
</tr>
<tr>
<td align="left">MSET key1 value1 key2 value2 …</td>
<td align="left">设置一个或多个指定 key 的值</td>
</tr>
<tr>
<td align="left">MGET key1 key2 …</td>
<td align="left">获取一个或多个指定 key 的值</td>
</tr>
<tr>
<td align="left">STRLEN key</td>
<td align="left">返回 key 所储存的字符串值的长度</td>
</tr>
<tr>
<td align="left">INCR key</td>
<td align="left">将 key 中储存的数字值增一</td>
</tr>
<tr>
<td align="left">DECR key</td>
<td align="left">将 key 中储存的数字值减一</td>
</tr>
<tr>
<td align="left">EXISTS key</td>
<td align="left">判断指定 key 是否存在</td>
</tr>
<tr>
<td align="left">DEL key（通用）</td>
<td align="left">删除指定的 key</td>
</tr>
<tr>
<td align="left">EXPIRE key seconds（通用）</td>
<td align="left">给指定 key 设置过期时间</td>
</tr>
</tbody></table>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>存储常规数据</p>
<ul>
<li>缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li>
</ul>
</li>
<li><p>需要计数的场景</p>
<ul>
<li>用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li>
</ul>
</li>
<li><p>分布式锁</p>
<ul>
<li>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。</li>
</ul>
</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>使用链表数据结构实现,Redis中使用的时双向链表,即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p>双向链表跨域实现队列以及栈</p>
<ul>
<li><strong>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>实现队列</strong> </li>
<li><strong>通过 <code>RPUSH/RPOP</code>或者<code>LPUSH/LPOP</code> 实现栈</strong> </li>
<li>通过 <code>LRANGE</code> 命令，你可以基于 List 实现分页查询，性能非常高！</li>
</ul>
<table>
<thead>
<tr>
<th>RPUSH key value1 value2 …</th>
<th>在指定列表的尾部（右边）添加一个或多个元素</th>
</tr>
</thead>
<tbody><tr>
<td>LPUSH key value1 value2 …</td>
<td>在指定列表的头部（左边）添加一个或多个元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>将指定列表索引 index 位置的值设置为 value</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移除并获取指定列表的第一个元素(最左边)</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取指定列表的最后一个元素(最右边)</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表元素数量</td>
</tr>
<tr>
<td>LRANGE key start end</td>
<td>获取列表 start 和 end 之间 的元素</td>
</tr>
</tbody></table>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>最新文章,最新动态</li>
<li>消息队列:<ul>
<li>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</li>
<li>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</li>
</ul>
</li>
</ul>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>String类型的键值对的映射表,适合存储对象,可以直接修改对象中的字段值</p>
<p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p>
<table>
<thead>
<tr>
<th>HSET key field value</th>
<th>设置指定哈希表中指定字段的值</th>
</tr>
</thead>
<tbody><tr>
<td>HSETNX key field value</td>
<td>只有指定字段不存在时设置指定字段的值</td>
</tr>
<tr>
<td>HMSET key field1 value1 field2 value2 …</td>
<td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取指定哈希表中指定字段的值</td>
</tr>
<tr>
<td>HMGET key field1 field2 …</td>
<td>获取指定哈希表中一个或者多个指定字段的值</td>
</tr>
<tr>
<td>HGETALL key</td>
<td>获取指定哈希表中所有的键值对</td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td>查看指定哈希表中指定的字段是否存在</td>
</tr>
<tr>
<td>HDEL key field1 field2 …</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>HLEN key</td>
<td>获取指定哈希表中字段的数量</td>
</tr>
</tbody></table>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>对象数据存储</p>
<ul>
<li>用户信息,商品信息,文章信息,购物车信息等等</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序不可重复</p>
<p>Set 提供了判断某个元素是否在一个 Set 集合内的重要接口</p>
<p> Set 能够轻易实现交集、并集、差集的操作,</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SADD key member1 member2 …</td>
<td align="left">向指定集合添加一个或多个元素</td>
</tr>
<tr>
<td align="left">SMEMBERS key</td>
<td align="left">获取指定集合中的所有元素</td>
</tr>
<tr>
<td align="left">SCARD key</td>
<td align="left">获取指定集合的元素数量</td>
</tr>
<tr>
<td align="left"><strong>SISMEMBER key member</strong></td>
<td align="left"><strong>判断指定元素是否在指定集合中</strong></td>
</tr>
<tr>
<td align="left">SINTER key1 key2 …</td>
<td align="left">获取给定所有集合的交集</td>
</tr>
<tr>
<td align="left">SINTERSTORE destination key1 key2 …</td>
<td align="left">将给定所有集合的交集存储在 destination 中</td>
</tr>
<tr>
<td align="left">SUNION key1 key2 …</td>
<td align="left">获取给定所有集合的并集</td>
</tr>
<tr>
<td align="left">SUNIONSTORE destination key1 key2 …</td>
<td align="left">将给定所有集合的并集存储在 destination 中</td>
</tr>
<tr>
<td align="left">SDIFF key1 key2 …</td>
<td align="left">获取给定所有集合的差集</td>
</tr>
<tr>
<td align="left">SDIFFSTORE destination key1 key2 …</td>
<td align="left">将给定所有集合的差集存储在 destination 中</td>
</tr>
<tr>
<td align="left">SPOP key count</td>
<td align="left">随机移除并获取指定集合中一个或多个元素</td>
</tr>
<tr>
<td align="left">SRANDMEMBER key count</td>
<td align="left">随机获取指定集合中指定数量的元素</td>
</tr>
</tbody></table>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>需要存放数据不能重复</p>
<ul>
<li>网站UV统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li>
</ul>
</li>
<li><p>需要获取多个交集、并集、差集的场景</p>
<ul>
<li>共同好友(交集),共同关注(交集),好友推荐(差集)等等</li>
</ul>
</li>
<li><p>需要随机获取数据源中的元素的场景</p>
<ul>
<li>抽奖</li>
<li><code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）</li>
</ul>
</li>
</ul>
<h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><p>类似于Sort,但相比于Sort多了一个权重score并按照权重排序,通过权重范围获取元素</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ZADD key score1 member1 score2 member2 …</td>
<td align="left">向指定有序集合添加一个或多个元素</td>
</tr>
<tr>
<td align="left">ZCARD KEY</td>
<td align="left">获取指定有序集合的元素数量</td>
</tr>
<tr>
<td align="left">ZSCORE key member</td>
<td align="left">获取指定有序集合中指定元素的 score 值</td>
</tr>
<tr>
<td align="left">ZINTERSTORE destination numkeys key1 key2 …</td>
<td align="left">将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td>
</tr>
<tr>
<td align="left">ZUNIONSTORE destination numkeys key1 key2 …</td>
<td align="left">求并集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td align="left">ZDIFF destination numkeys key1 key2 …</td>
<td align="left">求差集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td align="left">ZRANGE key start end</td>
<td align="left">获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td>
</tr>
<tr>
<td align="left">ZREVRANGE key start end</td>
<td align="left">获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td>
</tr>
<tr>
<td align="left">ZREVRANK key member</td>
<td align="left">获取指定有序集合中指定元素的排名(score 从大到小排序)</td>
</tr>
</tbody></table>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><p>需要随机获取数据源中的元素根据某个权重进行排序的场景</p>
<ul>
<li>微信步数排行榜,热搜排行榜</li>
</ul>
</li>
<li><p>需要存储的数据有优先级或者重要程度的场景。</p>
<ul>
<li>举例 ：优先级任务队列。</li>
<li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
</li>
</ul>
<h2 id="Redis数据同步和数据迁移如何做？"><a href="#Redis数据同步和数据迁移如何做？" class="headerlink" title="Redis数据同步和数据迁移如何做？"></a>Redis数据同步和数据迁移如何做？</h2><p><code>数据迁移</code> 这种一般比较好做，可以直接从源redis导出rdb，再把rdb文件导入目标redis。如果需要实时增量同步就 需要引用第三方工具</p>
<p>阿里云开源 的<code>redis-shake</code> 工具。</p>
<h1 id="如何防止表单的重复提交"><a href="#如何防止表单的重复提交" class="headerlink" title="如何防止表单的重复提交"></a>如何防止表单的重复提交</h1><h2 id="1-前端实现"><a href="#1-前端实现" class="headerlink" title="1.前端实现"></a>1.前端实现</h2><p>js设置点击按钮后使按钮失效,防止表单重复提交</p>
<p><strong>但js代码很容易被绕过。比如用户通过刷新页面方式，或使用postman等工具绕过前端页面仍能重复提交表单。因此不推荐此方法。</strong></p>
<h2 id="2-给数据库添加唯一键约束"><a href="#2-给数据库添加唯一键约束" class="headerlink" title="2.给数据库添加唯一键约束"></a>2.给数据库添加唯一键约束</h2><p>重新设计表结构</p>
<p>在代码中及时捕获异常</p>
<p><strong>通过数据库加唯一键约束能有效避免数据库重复插入相同数据。但无法阻止恶意用户重复提交表单（攻击网站），服务器大量执行sql插入语句，增加服务器和数据库负荷。</strong></p>
<h2 id="3-利用session防止表单重复提交"><a href="#3-利用session防止表单重复提交" class="headerlink" title="3.利用session防止表单重复提交"></a>3.利用session防止表单重复提交</h2><p>服务器返回表单页面时，会先生成一个subToken保存于session，并把该subToen传给表单页面。当表单提交时会带上subToken，服务器拦截器Interceptor会拦截该请求，拦截器判断session保存的subToken和表单提交subToken是否一致。若不一致或session的subToken为空或表单未携带subToken则不通过。</p>
<p>首次提交表单时session的subToken与表单携带的subToken一致走正常流程，然后拦截器内会删除session保存的subToken。当再次提交表单时由于session的subToken为空则不通过。从而实现了防止表单重复提交。</p>
<h2 id="4-使用AOP自定义切入实现"><a href="#4-使用AOP自定义切入实现" class="headerlink" title="4.使用AOP自定义切入实现"></a>4.使用AOP自定义切入实现</h2><ol>
<li>自定义防止重复提交标记（@AvoidRepeatableCommit）。</li>
<li>对需要防止重复提交的Congtroller里的mapping方法加上该注解。</li>
<li>新增Aspect切入点，为@AvoidRepeatableCommit加入切入点。</li>
<li>每次提交表单时，Aspect都会保存当前key到reids（须设置过期时间）。</li>
<li>重复提交时Aspect会判断当前redis是否有该key，若有则拦截。</li>
</ol>
<pre><code class="java">import java.lang.annotation.*;	
/**
 * 避免重复提交
 * @author hhz
 * @version
 * @since
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AvoidRepeatableCommit &#123;
    /**
     * 指定时间内不可重复提交,单位毫秒
     * @return
     */
    long timeout()  default 30000 ;
&#125;
</code></pre>
<pre><code class="java">/**
* 重复提交aop
* @author hhz
* @version 
* @since 
*/
@Aspect
@Component
public class AvoidRepeatableCommitAspect &#123;

@Autowired
private RedisTemplate redisTemplate;

/**
 * @param point
 */
@Around(&quot;@annotation(com.xwolf.boot.annotation.AvoidRepeatableCommit)&quot;)
public Object around(ProceedingJoinPoint point) throws Throwable &#123;

    HttpServletRequest request  = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest();
    String ip = IPUtil.getIP(request);
    //获取注解
    MethodSignature signature = (MethodSignature) point.getSignature();
    Method method = signature.getMethod();
    //目标类、方法
    String className = method.getDeclaringClass().getName();
    String name = method.getName();
    String ipKey = String.format(&quot;%s#%s&quot;,className,name);
    int hashCode = Math.abs(ipKey.hashCode());
    String key = String.format(&quot;%s_%d&quot;,ip,hashCode);
    log.info(&quot;ipKey=&#123;&#125;,hashCode=&#123;&#125;,key=&#123;&#125;&quot;,ipKey,hashCode,key);
    AvoidRepeatableCommit avoidRepeatableCommit =  method.getAnnotation(AvoidRepeatableCommit.class);
    long timeout = avoidRepeatableCommit.timeout();
    if (timeout &lt; 0)&#123;
                    //过期时间5分钟
        timeout = 60*5;
    &#125;
    String value = (String) redisTemplate.opsForValue().get(key);
    if (StringUtils.isNotBlank(value))&#123;
        return &quot;请勿重复提交&quot;;
    &#125;
    redisTemplate.opsForValue().set(key, UUIDUtil.uuid(),timeout,TimeUnit.MILLISECONDS);
    //执行方法
    Object object = point.proceed();
    return object;
&#125;
&#125;
</code></pre>
<h1 id="AOP-了解吗？有什么用？切面执行顺序如何控制？"><a href="#AOP-了解吗？有什么用？切面执行顺序如何控制？" class="headerlink" title="AOP 了解吗？有什么用？切面执行顺序如何控制？"></a>AOP 了解吗？有什么用？切面执行顺序如何控制？</h1><p>AOP(Aspect-Oriented Programming):面向切面编程,将那些与业务无关,但却被模块所共同调用的逻辑或责任,封装起来,有利于减少系统重复代码,降低模块间的耦合,也有利于后续的维护和扩展.</p>
<p>SpringAOP是基于动态代理的,如果要代理的对象实现了某个接口,那么使用<code>JDKProxy</code>创建代理对象,对于没有实现接口的对象,无法使用<code>JDKProxy</code>,SpringAOP会使用<code>Cglib</code>生成一个代理对象的子类作为代理.</p>
<blockquote>
<h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3><p>Spring AOP 是运行时增强,AspectJAOP是编译时增强</p>
<p>SpringAOP基于代理(proxy),AspectJAOP基于字节码操作</p>
<p>SpringAOP集成了AspectJAOP,AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 SpringAOP 相对来说更简单，</p>
<p>切面较少的情况下两者差别不大,当切面较多的时候建议使用AspectJAOP,速度比SpringAOP 快</p>
</blockquote>
<h2 id="AspectJAOP定义的通知类型"><a href="#AspectJAOP定义的通知类型" class="headerlink" title="AspectJAOP定义的通知类型"></a>AspectJAOP定义的通知类型</h2><ul>
<li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li>
<li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li>
<li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li>
<li><strong>AfterThrowing</strong>（异常通知） ：目标对象的方法运行中抛出 &#x2F; 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li>
<li><strong>Around</strong>：（环绕通知）编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li>
</ul>
<h2 id="切面执行顺序控制"><a href="#切面执行顺序控制" class="headerlink" title="切面执行顺序控制"></a>切面执行顺序控制</h2><p>使用<code>@Order</code>注解直接定义切面顺序</p>
<p>实现Order接口并重写getOrder方法</p>

    </div>
    
    
    
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Hexo
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;John Doe
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/myblog.github.io/js/main.js"></script>
        
        




        
    </body>
</html>
