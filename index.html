
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>Hexo</title>
        <meta name="author" content="John Doe" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202207200831813.jpeg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/myblog.github.io/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/myblog.github.io/js/lib/highlight.js"></script>



<script src="/myblog.github.io/js/lib/preview.js"></script>





<script src="/myblog.github.io/js/lib/home.js"></script>

<link rel="stylesheet" href="/myblog.github.io/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/myblog.github.io/images/loading.gif" />
                </div>
            </div>
            </transition>
            <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/myblog.github.io/">
            <span>HEXO</span>
        </a>
        
        <a href="/myblog.github.io/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/myblog.github.io/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/myblog.github.io/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/myblog.github.io/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/myblog.github.io/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;HEXO</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/myblog.github.io/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/myblog.github.io/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/myblog.github.io/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/myblog.github.io/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/myblog.github.io/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div id="home-head">
    <div id="home-background" ref="homeBackground" data-image="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202207241109164.jpg,https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202207200828249.png,https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com/blog9737304e873c5821696d17460a18e050.jpeg,https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202207211123142.jpg,https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com/blog/wallhaven-wq1o8p.jpg,https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com/blog/j3eemp.png"></div>
    
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Hexo</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
    
</div>
<div id="home-posts-wrap"  ref="homePostsWrap">
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/myblog.github.io/2023/07/04/vue%E5%8F%AF%E6%8B%96%E6%8B%BD%E8%A1%A8%E6%A0%BC%E5%AE%9E%E7%8E%B0/">
        <h2 class="post-title">vue可拖拽表格实现</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/7/4
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>cjb</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/myblog.github.io/tags/%E5%89%8D%E7%AB%AF/" style="color: #ff7d73">
                前端
            </a>
        </span>
        
    </div>
    <a href="/myblog.github.io/2023/07/04/vue%E5%8F%AF%E6%8B%96%E6%8B%BD%E8%A1%A8%E6%A0%BC%E5%AE%9E%E7%8E%B0/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/myblog.github.io/2023/05/24/docker-compose%E9%83%A8%E7%BD%B2kafka+zookeeper%E9%A1%B9%E7%9B%AE/">
        <h2 class="post-title">docker-compose部署kafka+zookeeper项目</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/5/24
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>cjb</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/myblog.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" style="color: #00a596">
                项目部署
            </a>
        </span>
        
    </div>
    <a href="/myblog.github.io/2023/05/24/docker-compose%E9%83%A8%E7%BD%B2kafka+zookeeper%E9%A1%B9%E7%9B%AE/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/myblog.github.io/2023/03/28/hello-world/">
        <h2 class="post-title">Hello World</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>how to use this theme</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/myblog.github.io/2023/03/28/hello-world/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/myblog.github.io/2022/12/22/Day21/">
        <h2 class="post-title">day21</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>请说出一次完整的 HTTP 请求所经历的7个步骤。 cookie与session 请概述一下 HTTP 状态码分为哪几类？每一类分别是什么数字开头？ 什么是线程池 ThreadLocal</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/myblog.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="color: #03a9f4">
                面试题
            </a>
        </span>
        
    </div>
    <a href="/myblog.github.io/2022/12/22/Day21/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/myblog.github.io/2022/12/22/Day20/">
        <h2 class="post-title">day20</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>底层数据结构选型 事务</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/myblog.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="color: #ff7d73">
                面试题
            </a>
        </span>
        
    </div>
    <a href="/myblog.github.io/2022/12/22/Day20/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/myblog.github.io/2022/12/22/Day19/">
        <h2 class="post-title">day19</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>线程池 Java并发 手写单例模式 HTTP和HTTPS，对称加密与非对称加密 Redis</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/myblog.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="color: #00a596">
                面试题
            </a>
        </span>
        
    </div>
    <a href="/myblog.github.io/2022/12/22/Day19/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/myblog.github.io/2022/12/22/Day18/">
        <h2 class="post-title">day18</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>JWT Redis数据结构 AOP HashMap的扩容机制</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/myblog.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="color: #ff7d73">
                面试题
            </a>
        </span>
        
    </div>
    <a href="/myblog.github.io/2022/12/22/Day18/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/myblog.github.io/2022/12/22/Day17/">
        <h2 class="post-title">day17</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><strong>EasyExcel所对应的实体类的属性一定要严格按照驼峰命名</strong></p>
<p>在委托事件模型中，源生成事件并把它发送给一个或多个监听器，每个监听器必须向事件源注册</p>
<p>在try中的代码可能会产生多种异常，需要多个catch进行捕获，catch中的参数有子父类关系，应该把子类异常放在父类异常之前捕获</p>
<p>执行顺序</p>
<p>静态代码块&gt;构造代码块&gt;构造方法</p>
<h1 id="String字符串常见的题目"><a href="#String字符串常见的题目" class="headerlink" title="String字符串常见的题目"></a>String字符串常见的题目</h1><h2 id="奇怪的nullnull"><a href="#奇怪的nullnull" class="headerlink" title="奇怪的nullnull"></a>奇怪的<code>nullnull</code></h2><pre><code class="java">public class Test1 &#123;
    private static String s1;
    private static String s2;

    public static void main(String[] args) &#123;
        String s= s1+s2;
        System.out.println(s);
    &#125;
&#125;
</code></pre>
<p>这段代码会输出<code>nullnull</code></p>
<p>首先来查看为null字符串的打印方式</p>
<pre><code class="java">public void print(String s) &#123;
    if (s == null) &#123;
        s = &quot;null&quot;;
    &#125;
    write(s);
&#125;
</code></pre>
<p>可以看到，为null的字符串会被转换为字符串“null”然后输出</p>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208112059750.png" alt="0aa00c3f-97fb-42b6-9297-812b2b0b7b60"></p>
<p>编译器会对字符串相加的操作进行优化，转而使用StringBuilder的append方法拼接字符串。</p>
<p>如果append的字符串为null则</p>
<pre><code class="java">public AbstractStringBuilder append(String str) &#123;
    if (str == null)
        return appendNull();
        //...
&#125;
</code></pre>
<p>接着调用其父类AbstractStringBuilder的appendNull方法</p>
<pre><code class="java">private AbstractStringBuilder appendNull() &#123;
    int c = count;
    ensureCapacityInternal(c + 4);
    final char[] value = this.value;
    value[c++] = &#39;n&#39;;
    value[c++] = &#39;u&#39;;
    value[c++] = &#39;l&#39;;
    value[c++] = &#39;l&#39;;
    count = c;
    return this;
&#125;
</code></pre>
<p>此处使用了char字符数组来存储null字符串的值，所以StringBuilder对null字符串进行了特殊的处理，会将null转换成”null”字符串并将其添加进字符数组，这也就导致了	两个为空的字符串相加后输出为<code>nullnull</code></p>
<h2 id="String值的问题"><a href="#String值的问题" class="headerlink" title="String值的问题"></a>String值的问题</h2><pre><code class="java">String s=&quot;Hydra&quot;;
s=&quot;Trunks&quot;;
</code></pre>
<p>虽然此处的s值被修改了，但实际上这是新创建了一个String对象，String的值是不可改变的,下面是String的源码</p>
<pre><code class="java">private final char value[];
</code></pre>
<p>可以看书，String在本质上就是一个char数组，且被final修饰，说明不能被更改，这里的不能被更改指的是 无法修改其地址，其数组中的值还是可以被修改的。</p>
<p>如下所示：</p>
<pre><code class="JAVA">final char[] one=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;
char[] two=&#123;&#39;d&#39;,&#39;e&#39;,&#39;f&#39;&#125;;
one=two;
</code></pre>
<p>此处会报错<code>Cannot assign a value to final variable &#39;one&#39;</code>，说明被final修饰的数组的引用无法被修改</p>
<p>但我们可以直接操作数组内的元素</p>
<pre><code class="java">final char[] one=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;
one[1]=&#39;z&#39;;
</code></pre>
<p>​	<img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208112006823.png" alt="img"></p>
<p>我们直接用hashcode来查看引用指向的对象是否发生改变</p>
<pre><code class="JAVA">public static void main(String[] args) &#123;
    String s=&quot;Hydra&quot;;
    System.out.println(s+&quot;:  &quot;+s.hashCode());
    s=&quot;Trunks&quot;;
    System.out.println(s+&quot;: &quot;+s.hashCode());
&#125;
</code></pre>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208112010720.png" alt="b1f213da-223c-4246-aece-e9392a454941"></p>
<p>可以看到这两个对象的引用指向的对象不是同一个</p>
<p>可以使用反射来实现不改变对象引用的情况下修改对象的值</p>
<pre><code class="JAVA">public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123;
    String s=&quot;Hydra&quot;;
    System.out.println(s+&quot;:  &quot;+s.hashCode());

    Field field = String.class.getDeclaredField(&quot;value&quot;);
    field.setAccessible(true);
    field.set(s,new char[]&#123;&#39;T&#39;,&#39;r&#39;,&#39;u&#39;,&#39;n&#39;,&#39;k&#39;,&#39;s&#39;&#125;);
    System.out.println(s+&quot;: &quot;+s.hashCode());
&#125;
</code></pre>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208112011534.png" alt="27f11d5a-4106-4aef-8df5-dc178d414470"></p>
<h2 id="创建几个对象？"><a href="#创建几个对象？" class="headerlink" title="创建几个对象？"></a>创建几个对象？</h2><pre><code class="java">String s = new String(&quot;Hydra&quot;);
</code></pre>
<p>以上代码创建了几个对象？</p>
<p>首先了解常量池的相关知识</p>
<ul>
<li>class 文件常量池：在 class 文件中保存了一份常量池（ Constant Pool ），主要 存储编译时确定的数据，包括代码中的字面量( literal )和符号引用 </li>
<li>运行时常量池：位于方法区中，全局共享，class 文件常量池中的内容会在类加载后 存放到方法区的运行时常量池中。除此之外，在运行期间可以将新的变量放入运行 时常量池中，相对 class 文件常量池而言运行时常量池更具备动态性 </li>
<li>字符串常量池：位于堆中，全局共享，这里可以先粗略的认为它存储的是 String 对 象的直接引用，而不是直接存放的对象，具体的实例对象是在堆中存放</li>
</ul>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208112028550.png" alt="28f7d214-c451-4e77-abe9-e65343c4f428"></p>
<p>字符串常量池StringTable本质上是一张HashTable，运用数组+链表结构</p>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208112028780.png" alt="1d8eb77b-3fb3-4598-865c-ab6792ea866f"></p>
<p>使用字面量声明 String 对象时，也就是被双引号包围的字符串，在堆上创建对象， 并驻留到字符串常量池中（注意这个用词） </p>
<p>调用 <strong>intern()</strong> 方法，当字符串常量池没有相等的字符串时，会保存该字符串的引 用</p>
<p>简单来说，String对象的引用保存在字符串常量池中</p>
<pre><code class="JAVA">public static void main(String[] args) &#123;
    String s = &quot;Hydra&quot;;
&#125;
</code></pre>
<p>反编译后：</p>
<pre><code class="java">public static void main(java.lang.String[]);
  descriptor: ([Ljava/lang/String;)V
  flags: ACC_PUBLIC, ACC_STATIC
  Code:
    stack=1, locals=2, args_size=1
       0: ldc           #2                  // String Hydra
       2: astore_1
       3: return
</code></pre>
<ul>
<li>0: ldc ，查找后面索引为 #2 对应的项， #2 表示常量在常量池中的位置。在这 个过程中，会触发前面提到的lazy resolve，在 resolve 过程<strong>如果发现 StringTab le 已经有了内容匹配的 String 引用，则直接返回这个引用，反之如果 StringTa ble 里没有内容匹配的 String 对象的引用，则会在堆里创建一个对应内容的 String 对象</strong>，然后在 StringTable 驻留这个对象引用，并返回这个引用，之后再压入操 作数栈中 </li>
<li>2: astore_1 ，弹出栈顶元素，并将栈顶引用类型值保存到局部变量 1 中，也就 是保存到变量 s 中 </li>
<li>3: return ，执行 void 函数返回</li>
</ul>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208112036367.png" alt="92144f5e-a19f-42d1-8629-9cadf2371688"></p>
<p>显而易见这种方式值创建了一个对象</p>
<pre><code class="java">public static void main(String[] args) &#123;
    String s = new String(&quot;Hydra&quot;);
&#125;
</code></pre>
<p>反编译后：</p>
<pre><code class="java">public static void main(java.lang.String[]);
  descriptor: ([Ljava/lang/String;)V
  flags: ACC_PUBLIC, ACC_STATIC
  Code:
    stack=3, locals=2, args_size=1
       0: new           #2                  // class java/lang/String
       3: dup
       4: ldc           #3                  // String Hydra
       6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V
       9: astore_1
      10: return
</code></pre>
<p>和之前的不同之处：</p>
<ul>
<li>0: new ，在堆上创建一个 String 对象，并将它的引用压入操作数栈，<strong>注意这时的 对象还只是一个空壳</strong>，并没有调用类的构造方法进行初始化 </li>
<li>3: dup ，复制栈顶元素，也就是复制了上面的对象引用，并将复制后的对象引用 压入栈顶。这里之所以要进行复制，是因为之后要执行的构造方法会从操作数栈弹 出需要的参数和这个对象引用本身（这个引用起到的作用就是构造方法中的 this 指针），如果不进行复制，在弹出后会无法得到初始化后的对象引用 </li>
<li>4: ldc ，在堆上创建字符串对象，驻留到字符串常量池，并将字符串的引用压入 操作数栈</li>
<li>6: invokespecial ，执行 String 的构造方法，这一步执行完成后得到一个完整 对象</li>
</ul>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208112037755.png" alt="820121d0-ca33-44d4-8968-69d5a9c889f5"></p>
<p>创建了两个对象</p>
<pre><code class="java">public static void main(String[] args) &#123;
    String s = &quot;Hydra&quot;;
    String s2 = new String(&quot;Hydra&quot;);
&#125;
</code></pre>
<pre><code class="java">Code:
  stack=3, locals=3, args_size=1
     0: ldc           #2                  // String Hydra
     2: astore_1
     3: new           #3                  // class java/lang/String
     6: dup
     7: ldc           #2                  // String Hydra
     9: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V
    12: astore_2
    13: return
</code></pre>
<p>值创建了一个对象</p>
<p>可以看到两次执行 ldc 指令时后面索引相同，而 ldc 判断是否需要创建新的 String 实例的依据是根据 在第一次执行这条指令时， StringTable 是否已经保存了一个对应内容的 String 实例的引用。所以在 第一次执行 ldc 时会创建 String 实例，而在第二次 ldc 就会直接返回而不需要再创建实例了。</p>
<h2 id="intern（）"><a href="#intern（）" class="headerlink" title="intern（）"></a>intern（）</h2><p>String 的 intern() 是一个本地方法，可以强制将 String 驻留进入字符串常量池，可 以分为两种情况： </p>
<ul>
<li>如果字符串常量池中已经驻留了一个等于此 String 对象内容的字符串引用，则返回 此字符串在常量池中的引用</li>
<li>否则，在常量池中创建一个引用指向这个 String 对象，然后返回常量池中的这个引 用</li>
</ul>
<pre><code class="java">public static void main(String[] args) &#123;
    String s1 = new String(&quot;Hydra&quot;);
    String s2 = s1.intern();
    System.out.println(s1 == s2);
    System.out.println(s1 == &quot;Hydra&quot;);
    System.out.println(s2 == &quot;Hydra&quot;);
&#125;


输出：
false
false
true
</code></pre>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208112048992.png" alt="34a59f7f-c3ee-4fd9-ace8-8be54bc4838d"></p>
<ul>
<li><p>在创建 s1 的时候，其实堆里已经创建了两个字符串对象 StringObject1 和 Str ingObject2 ，并且在字符串常量池中驻留了 StringObject2 </p>
</li>
<li><p>当执行 s1.intern() 方法时，字符串常量池中已经存在内容等于 “Hydra” 的字 符串 StringObject2 ，直接返回这个引用并赋值给 s2 s1 和 s2 指向的是两个不同的 String 对象，因此返回 fasle</p>
</li>
<li><p>s2 指向的就是驻留在字符串常量池的 StringObject2 ，因此 s2&#x3D;&#x3D;”Hydra” 为 true，而 s1 指向的不是常量池中的对象引用所以返回 false</p>
</li>
<li><p>s1指向的是创建的对象，s2指向的是常量池中已经存在的对象的引用</p>
</li>
</ul>
<pre><code class="java">public static void main(String[] args) &#123;
    String s1 = new String(&quot;Hy&quot;) + new String(&quot;dra&quot;);
    s1.intern();
    String s2 = &quot;Hydra&quot;;
    System.out.println(s1 == s2);
&#125;

输出结果：
    true
</code></pre>
<p>第一步会在堆上创建 “Hy” 和 “dra” 的字符串对象，并驻留 到字符串常量池中。</p>
<p> 接下来，完成字符串的拼接操作，前面我们说过，实际上 jvm 会把拼接优化成 String Builder 的 append 方法，并最终调用 toString 方法返回一个 String 对象。在完成 字符串的拼接后，字符串常量池中并没有驻留一个内容等于 “Hydra” 的字符串。</p>
<p>所以，执行 s1.intern() 时，会在字符串常量池创建一个引用，指向前面 StringBuilder 创建的那 个字符串，也就是变量 s1 所指向的字符串对象</p>
<p>String s2 &#x3D; “Hydra”;直接引用常量池中已经存在的字符串对象，所以s1,s2 指向的是同一个对象</p>
<h2 id="常量折叠"><a href="#常量折叠" class="headerlink" title="常量折叠"></a>常量折叠</h2><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
<p>对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code></p>
<p>并不是所有的常量都会进行折叠，只有在编译器能够确定值的常量才可以</p>
<ul>
<li>基本数据类型以及String类型</li>
<li>final修饰的基本数据类型和字符串变量</li>
<li>字符串的+拼接，基本数据类型的加减乘除和位运算</li>
<li>声明时就已经初始化</li>
<li>使用常量表达式进行初始化</li>
</ul>
<p>字符串使用final修时后可以让编译器当作常量来使用</p>
<pre><code class="java">final String str1 = &quot;str&quot;;
final String str2 = &quot;ing&quot;;
// 下面两个表达式其实是等价的
String c = &quot;str&quot; + &quot;ing&quot;;// 常量池中的对象
String d = str1 + str2; // 常量池中的对象
System.out.println(c == d);// true
</code></pre>
<pre><code class="java">public static void main(String[] args) &#123;
    final String h1 = &quot;hello&quot;;
    String h2 = &quot;hello&quot;;
    String s1 = h1 + &quot;Hydra&quot;;
    String s2 = h2 + &quot;Hydra&quot;;
    System.out.println((s1 == &quot;helloHydra&quot;));
    System.out.println((s2 == &quot;helloHydra&quot;));
&#125;
输出结果
true
false
</code></pre>
<p> <strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化</strong></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/myblog.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="color: #00bcd4">
                面试题
            </a>
        </span>
        
    </div>
    <a href="/myblog.github.io/2022/12/22/Day17/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/myblog.github.io/2022/12/22/Day16/">
        <h2 class="post-title">day16</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <ul>
<li>抽象类</li>
</ul>
<p>可以实现接口，也可以继承自抽象类 </p>
<p>必须由“abstract class”修饰</p>
<p>可以包含也可以不包含抽象方法</p>
<p>和接口一样不能被实例化</p>
<ul>
<li>构造函数</li>
</ul>
<p>构造函数不能被继承只能被显式或隐式的调用</p>
<p>比如子类用super调用父类的构造方法</p>
<h2 id="maven与Ant"><a href="#maven与Ant" class="headerlink" title="maven与Ant"></a>maven与Ant</h2><h3 id="Ant"><a href="#Ant" class="headerlink" title="Ant"></a><strong>Ant</strong></h3><p>是一种基于Java的build工具</p>
<ul>
<li>能够用ant编译java类。生成class文件</li>
<li>ant能够自己定义标签、配置文件，用于构建。</li>
<li>ant能够把相关层构建成jar包 。</li>
<li>ant把整个项目生成web包。并公布到Tomcat</li>
</ul>
<p>Ant的长处：</p>
<ul>
<li><p><strong>跨平台性</strong>：Ant是纯Java语言编写的，因此具有非常好的跨平台性。</p>
</li>
<li><p><strong>操作简单</strong>：Ant是由一个内置任务和可选任务组成的。Ant执行时需要一个XML文件(构建文件)。</p>
</li>
<li><p><strong>Ant通过调用target树，就能够运行各种task</strong>：每一个task实现了特定接口对象。因为Ant构建文件时XML格式的文件。所以非常easy维护和书写，并且结构非常清晰。</p>
</li>
<li><p><strong>Ant能够集成到开发环境中</strong>：因为Ant的跨平台性和操作简单的特点。它非常easy集成到一些开发环境中去。</p>
</li>
</ul>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h3><p>除了以程序构建能力为特色之外，还提供高级项目管理工具。 </p>
<p>Maven除了具备Ant的功能外。还添加了下面基本的功能：</p>
<ul>
<li>使用Project Object Model来对软件项目管理。</li>
<li>内置了很多其它的隐式规则，使得构建文件更加简单。</li>
<li>内置依赖管理和Repository来实现依赖的管理和统一存储；</li>
<li>内置了软件构建的生命周期；</li>
</ul>
<p>Maven的长处：</p>
<ul>
<li>拥有约定，知道你的代码在哪里，放到哪里去</li>
<li>拥有一个生命周期，比如运行 mvn install就能够自己主动运行编译，測试。打包等构建过程</li>
<li>仅仅须要定义一个pom.xml,然后把源代码放到默认的文件夹，Maven帮你处理其它事情</li>
<li>拥有依赖管理。仓库管理</li>
</ul>
<p>总体的比较：</p>
<p>​    Ant将提供了非常多能够重用的task，比如 copy, move, delete以及junit单元测试，Maven则提供了非常多能够重用的过程。</p>
<h1 id="泛型-amp-通配符"><a href="#泛型-amp-通配符" class="headerlink" title="泛型&amp;通配符"></a>泛型&amp;通配符</h1><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>泛型时JDK5引入的一个新特性，使用泛型可以增强代码的可读性和稳定性。</p>
<blockquote>
<p>作用</p>
</blockquote>
<p>编译器可以对泛型参数进行检测，并通过泛型参数指定传入的对象类型。没使用泛型前，原生的List的返回类型是Object，需要强转 ，使用了泛型后，编译器自动转换。</p>
<h2 id="泛型的使用方式"><a href="#泛型的使用方式" class="headerlink" title="泛型的使用方式"></a>泛型的使用方式</h2><ul>
<li>类</li>
<li>接口</li>
<li>方法</li>
</ul>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><pre><code class="JAVA">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic&lt;T&gt;&#123;

    private T key;

    public Generic(T key) &#123;
        this.key = key;
    &#125;

    public T getKey()&#123;
        return key;
    &#125;
&#125;
</code></pre>
<p>实例化泛型类必须指定具体的类型</p>
<pre><code class="JAVA">Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);
</code></pre>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre><code class="JAVA">public interface Generator&lt;T&gt; &#123;
    public T method();
&#125;
</code></pre>
<p>实现接口，不指定类型</p>
<pre><code class="JAVA">class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;&#123;
    @Override
    public T method() &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>实现接口，指定类型</p>
<pre><code class="JAVA">class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;&#123;
    @Override
    public String method() &#123;
        return &quot;hello&quot;;
    &#125;
&#125;
</code></pre>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><pre><code class="JAVA">   public static &lt; E &gt; void printArray( E[] inputArray )
   &#123;
         for ( E element : inputArray )&#123;
            System.out.printf( &quot;%s &quot;, element );
         &#125;
         System.out.println();
    &#125;
</code></pre>
<p>使用</p>
<pre><code class="JAVA">// 创建不同类型数组： Integer, Double 和 Character
Integer[] intArray = &#123; 1, 2, 3 &#125;;
String[] stringArray = &#123; &quot;Hello&quot;, &quot;World&quot; &#125;;
printArray( intArray  );
printArray( stringArray  );
</code></pre>
<h2 id="项目中经常使用泛型的地方"><a href="#项目中经常使用泛型的地方" class="headerlink" title="项目中经常使用泛型的地方"></a>项目中经常使用泛型的地方</h2><h3 id="自定义统一的返回结果"><a href="#自定义统一的返回结果" class="headerlink" title="自定义统一的返回结果"></a>自定义统一的返回结果</h3><pre><code class="JAVA">package com.gong.util;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

/**
 * @description:传给前端数据的封装
 * @author:gong
 * @create: 7/8/2022 下午2:29
 */
@Data
@ApiModel(value = &quot;全局统一返回结果&quot;)
public class Result&lt;T&gt; &#123;
    @ApiModelProperty(value = &quot;返回码&quot;)
    private Integer code;

    @ApiModelProperty(value = &quot;返回消息&quot;)
    private String message;

    @ApiModelProperty(value = &quot;返回数据&quot;)
    private T data;

    public Result()&#123;&#125;

    // 返回数据
    protected static &lt;T&gt; Result&lt;T&gt; build(T data) &#123;
        Result&lt;T&gt; result = new Result&lt;T&gt;();
        if (data != null) &#123;
            result.setData(data);
        &#125;
        return result;
    &#125;

    public static &lt;T&gt; Result&lt;T&gt; build(T body, ResultCodeEnum resultCodeEnum) &#123;
        Result&lt;T&gt; result = build(body);
        result.setCode(resultCodeEnum.getCode());
        result.setMessage(resultCodeEnum.getMessage());
        return result;
    &#125;

    public static&lt;T&gt; Result&lt;T&gt; ok()&#123;
        return Result.ok(null);
    &#125;

    /**
     * 操作成功
     * @param data
     * @param &lt;T&gt;
     * @return
     */
    public static&lt;T&gt; Result&lt;T&gt; ok(T data)&#123;
        Result&lt;T&gt; result = build(data);
        return build(data, ResultCodeEnum.SUCCESS);
    &#125;

    public static&lt;T&gt; Result&lt;T&gt; fail()&#123;
        return Result.fail(null);
    &#125;

    /**
     * 操作失败
     * @param data
     * @param &lt;T&gt;
     * @return
     */
    public static&lt;T&gt; Result&lt;T&gt; fail(T data)&#123;
        Result&lt;T&gt; result = build(data);
        return build(data, ResultCodeEnum.FAIL);
    &#125;

    public Result&lt;T&gt; message(String msg)&#123;
        this.setMessage(msg);
        return this;
    &#125;

    public Result&lt;T&gt; code(Integer code)&#123;
        this.setCode(code);
        return this;
    &#125;

    public boolean isOk() &#123;
        if(this.getCode().intValue() == ResultCodeEnum.SUCCESS.getCode().intValue()) &#123;
            return true;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h3 id="定义Excel处理类ExcelUtil用于动态指定Excel导出的数据类型"><a href="#定义Excel处理类ExcelUtil用于动态指定Excel导出的数据类型" class="headerlink" title="定义Excel处理类ExcelUtil用于动态指定Excel导出的数据类型"></a>定义Excel处理类ExcelUtil<T>用于动态指定Excel导出的数据类型</h3><h3 id="构建集合工具类"><a href="#构建集合工具类" class="headerlink" title="构建集合工具类"></a>构建集合工具类</h3><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>Java的泛型是伪泛型，Java在编译期间会把所有的泛型信息擦除，这就是通常所说的泛型擦除</p>
<p>编译器在编译期间会把泛型T擦除为Object类型，T  extends  xxx，会被擦除成xxx类型</p>
<p>泛型本质上是编译器的行为，泛型擦除是为了保证引入泛型机制但不创建新的类型，减少虚拟机的运行开销，将泛型类转换成一般类</p>
<pre><code class="JAVA">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

list.add(12);
//1.编译期间直接添加会报错
list.add(&quot;a&quot;);
Class&lt;? extends List&gt; clazz = list.getClass();
Method add = clazz.getDeclaredMethod(&quot;add&quot;, Object.class);
//2.运行期间通过反射添加，是可以的
add.invoke(list, &quot;kl&quot;);

System.out.println(list)
</code></pre>
<p>这里可以看出在运行期间，泛型已经被擦除了。</p>
<pre><code class="JAVA">public void print(List&lt;String&gt; list)  &#123; &#125;
public void print(List&lt;Integer&gt; list) &#123; &#125;
</code></pre>
<p>由于擦除问题，导致该重载报错</p>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208102045850.png" alt="img"></p>
<h4 id="既然编译器要擦除，那为什么还要用泛型呢？"><a href="#既然编译器要擦除，那为什么还要用泛型呢？" class="headerlink" title="既然编译器要擦除，那为什么还要用泛型呢？"></a>既然编译器要擦除，那为什么还要用泛型呢？</h4><ul>
<li>使用泛型可以在编译器进行类型检测</li>
<li>不需要手动添加类型转换，提高代码的可读性和稳定性</li>
<li>泛型可以使用自限定类型比如 T extends xxx.</li>
</ul>
<h2 id="桥方法"><a href="#桥方法" class="headerlink" title="桥方法"></a>桥方法</h2><p>用于继承泛型类时保证多态</p>
<pre><code class="JAVA">class Node&lt;T&gt; &#123;
    public T data;
    public Node(T data) &#123; this.data = data; &#125;
    public void setData(T data) &#123;
        System.out.println(&quot;Node.setData&quot;);
        this.data = data;
    &#125;
&#125;

class MyNode extends Node&lt;Integer&gt; &#123;
    public MyNode(Integer data) &#123; super(data); &#125;

      // Node&lt;T&gt; 泛型擦除后为 setData(Object data)，而子类 MyNode 中并没有重写该方法，所以编译器会加入该桥方法保证多态
       public void setData(Object data) &#123;
        setData((Integer) data);
    &#125;

    public void setData(Integer data) &#123;
        System.out.println(&quot;MyNode.setData&quot;);
        super.setData(data);
    &#125;
&#125;
</code></pre>
<p>桥方法由编译器自动生成，无需手动编写。</p>
<h2 id="泛型的一些限制"><a href="#泛型的一些限制" class="headerlink" title="泛型的一些限制"></a>泛型的一些限制</h2><p>一般是因为擦除机制导致的</p>
<ul>
<li>只能声明，不能实例化T类型变量</li>
<li>泛型参数不能是基本数据类型，因为基本数据类型不是Object的子类</li>
<li>不能实例化泛型数组，擦除后Object无法进行类型判断。《Thinking in java》一书中指出，由于泛型具有擦除机制，在运行时的类型参数会被擦除，Java只知道存储的对象是一个Object而已，而对于Java的数组来说，他必须知道它持有的所有对象的具体类型，而泛型的这种运行时擦除机制违反了数组安全检查的原则。</li>
<li>泛型无法使用<code>instance  of</code>和<code>getClass</code>判断类型</li>
<li>不能实现两个不同泛型的同一接口，泛型擦除后多个父类的桥方法将产生冲突</li>
<li>不能用static修饰泛型变量</li>
</ul>
<pre><code class="java">public final class Algorithm &#123;
    public static &lt;T&gt; T max(T x, T y) &#123;
        return x &gt; y ? x : y;
    &#125;
&#125;
</code></pre>
<p>这个代码无法编译，x,y,擦除后都是Object类型，无法用&gt; 进行比较</p>
<h2 id="什么是通配符"><a href="#什么是通配符" class="headerlink" title="什么是通配符"></a>什么是通配符</h2><p>泛型类型是固定的，不太灵活，通配符可以类型参数变化，解决泛型无法<strong>协变</strong> 的问题。</p>
<p><strong>协变</strong>指的就是如果Child是Parent的子类，那么List<Child> 也应该是List<Parent> 的子类，但是泛型是不支持的。</p>
<h3 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h3><p>无界通配符可以接收任何泛型类型数据，用于实现不依赖于具体类型参数的简单方法，可以捕获参数类型并交与泛型方法处理</p>
<pre><code class="JAVA">void testMethod(Person&lt;?&gt; p) &#123;
  // 泛型方法自行处理
&#125;
</code></pre>
<p>List&lt;?&gt; list :表示持有某种特定类型的List，但不知道具体是哪一种，因此，我们添加元素进去会 报错</p>
<p>List list :表示元素的数据类型是Object，因此可以添加任何类型的对象</p>
<pre><code class="JAVA">List&lt;?&gt; list = new ArrayList&lt;&gt;();
list.add(&quot;sss&quot;);//报错
List list2 = new ArrayList&lt;&gt;();
list2.add(&quot;sss&quot;);//警告信息
</code></pre>
<h3 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h3><p>extends 可以实现泛型的向上转型，即传入的实参的类型必须是指定类型的 子类型</p>
<pre><code class="JAVA">// 限制必须是 Person 类的子类
&lt;? extends Person&gt;
</code></pre>
<p><strong>T extends xxx 和 ? extends xxx 又有什么区别?</strong></p>
<p>T extends xxx 用于定义泛型类和方法,擦除后为 xxx 类型, ? extends xxx 用于声明方法形参，接收xxx和其子类型</p>
<h3 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h3><p>super 与上边界通配符 extends刚好相反,它可以实现泛型的向下转型，即传入的类型实惨 必须是指定类型的父类型 </p>
<pre><code class="JAVA">//  限制必须是 Employee 类的父类
List&lt;? super Employee&gt;
</code></pre>
<p><strong>? extends xxx 和 ? super xxx 有什么区别?</strong></p>
<p>接收的参数的范围不同，前者只能 get,后者只能set</p>
<p>上边界通配符指明了父类型，不确定子类型，因此只能从父类取数据，不能存数据；下边界通配符指明了子类型，不确定父类型，因此只能子类存数据，不能子类取数据。</p>
<p>Class&lt;?&gt;和Class 的区别</p>
<p>直接使用Class会产生类型警告，使用Class&lt;?&gt;则没有，因为Class是一个泛型类，接收原生类型会产生警告</p>
<pre><code class="JAVA">class Shape &#123; /* ... */ &#125;
class Circle extends Shape &#123; /* ... */ &#125;
class Rectangle extends Shape &#123; /* ... */ &#125;

class Node&lt;T&gt; &#123; /* ... */ &#125;

ChildNode&lt;Circle&gt; nc = new Node&lt;&gt;();
Node&lt;Shape&gt;  ns = nc;
</code></pre>
<p>不能编译，因为 ChildNode<Circle> 不是 Node<Circle> 的子类</p>
<pre><code class="java">class Shape &#123; /* ... */ &#125;
class Circle extends Shape &#123; /* ... */ &#125;
class Rectangle extends Shape &#123; /* ... */ &#125;

class Node&lt;T&gt; &#123; /* ... */ &#125;
class ChildNode&lt;T&gt; extends Node&lt;T&gt;&#123;

&#125;
ChildNode&lt;Circle&gt; nc = new ChildNode&lt;&gt;();
Node&lt;Circle&gt;  ns = nc;
</code></pre>
<p>能编译，因为 ChildNode<Circle> 是 Node<Circle> 的子类</p>
<pre><code class="JAVA">public static void print(List&lt;? extends Number&gt; list) &#123;
    for (Number n : list)
        System.out.print(n + &quot; &quot;);
    System.out.println();
&#125;
</code></pre>
<p>可以编译， List 可以往外取元素，但是无法调用 add() 添加元素。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/myblog.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="color: #03a9f4">
                面试题
            </a>
        </span>
        
    </div>
    <a href="/myblog.github.io/2022/12/22/Day16/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/myblog.github.io/2022/12/22/Day15/">
        <h2 class="post-title">day15</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>常见的代码优化技术有：复写传播，删除死代码, 强度削弱，归纳变量删除</p>
<p>servlet的生命周期</p>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208091937217.png" alt="image-20220809193728113"></p>
<p>final修饰的变量不是一定要在定义时初始化，也可以在构造函数中完成初始化</p>
<p>final修饰的方法不能被子类重写，但可以重载</p>
<img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208092043375.png" alt="image-20220809204315289" style="zoom:33%;" />

<p>File类的一下常用方法和说明<br><strong>1.访问文件名相关方法：</strong></p>
<p>String getName(); 返回此File对象所表示的文件名和路径名（如果是路径，则返回最后一级子路径名）。<br>String getPath(); 返回此File对象所对应的路径名。<br>File getAbsolutePath(); 返回此File对象所对应的绝对路径名。<br>String getParent(); 返回此File对象所对应目录（最后一级子目录）的父路径名。<br>boolean renameTo(File newName); 重命名此File对象所对应的文件或目录，如果重命名成功，则返回true:否则返回false.（A）<br><strong>2.文件检测相关方法</strong></p>
<p>boolean exists(); 判断File对象所对应的文件或目录是否存在。<br>boolean canWrite(); 判断File对象所对应的目录或文件是否可写。<br>boolean canRead(); 判断File对象所对应的目录或文件是否可读。<br>boolean isFile(); 判断File对象所对应的是否是文件，而不是目录。<br>boolean isDirectory(); 判断File对象所对应的是否是目录，而不是文件。<br>boolean isAbsolute(); 判断File对象所对应的文件或目录是否是绝对路径。该方法消除了不同平台的差异，可以直接判断File对象是否为绝对路径。在UNIX&#x2F;Linux&#x2F;BSD等系统上，如果路径名开头是一条斜线（&#x2F;）,则表明该File对象对应一个绝对路径；在Windows等系统上，如果路径开头是盘符，则说明它是绝对路径。<br><strong>3.获取常规文件信息</strong></p>
<p>long lastModified(); 返回文件最后修改时间。<br>long length(); 返回文件内容的长度。<br><strong>4.文件操作相关的方法</strong></p>
<p>boolean createNewFile(); 当此File对象所对应的文件不存在时，该方法将新建的一个该File对象所指定的新文件，如果创建成功则返回true；否则返回false.(C)<br>boolean delete(); 删除File对象所对应的文件或路径。<br>static File CreateTempFile(String prefix,String suffix);在默认的临时文件目录创建一个临时空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。这是一个静态方法，可以直接通过File来调用。preFix参数必须至少是3个字节长。建议前缀使用一个短的、有意义的字符串。建议前缀使用一个短的、有意义的字符串，比如”hjb“ 或”main”. suffix参数可以为null,在这种情况下，将使用默认的后缀”.tmp”.<br>static File CreateTempFile(String prefix,String suffix,File directory);在directory所指定的目录中创建一个临时空文件，使用给定前缀、系统生成的随机数和给定后缀作为文件名。这是一个静态方法，可以直接通过File来调用。<br>void deleteOnExit(); 注册一个删除钩子，指定当Java虚拟机退出时，删除File对象随对应的文件和目录。<br><strong>5.目录操作相关方法（D）</strong></p>
<p>boolean mkdir(); 试图创建一个File对象所对应的目录，如果创建成功，则返回true;否则返回false. 调用该方法时File对象必须对应一个路径，而不是一个文件。<br>String[] list(); 列出File对象的所有子文件名和路径名，返回String数组。<br>File[] listFiles(); 列出File对象的所有子文件和路径，返回File数组。<br>static File[] listRoots(); 列出系统所有的根路径。这是一个静态方法，可以直接通过File类来调用。</p>
<img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208092043004.png" alt="image-20220809204333910" style="zoom:33%;" />

<p>1、为了更好地组织类，Java提供了包机制。包是类的容器，用于分隔类名空间。如果没有指定包名，所有的示例都属于一个默认的无名包。Java中的包一般均包含相关的类，java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。A错</p>
<ol start="2">
<li>import语句并没有将对应的java源文件拷贝到此处仅仅是引入，告诉编译器有使用外部文件，编译的时候要去读取这个外部文件。B错3、Java提供的包机制与IDE没有关系。C错4、定义在同一个包（package）内的类可以不经过import而直接相互使用。</li>
</ol>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="八中基本数据类型"><a href="#八中基本数据类型" class="headerlink" title="八中基本数据类型"></a>八中基本数据类型</h2><ol>
<li>byte 占用一个字节 默认值为 0</li>
<li>short 占用两个字节 默认值为 0</li>
<li>int  占用四个字节 默认值为 0</li>
<li>long 占用八个字节 默认值为 0L</li>
<li>float 占用四个字节 默认值为 0f</li>
<li>double 占用八个字节 默认值为 0d</li>
<li>boolean 逻辑上占一位，实际情况中可能会有不同 默认值为 false</li>
<li>char 占用两个字节 默认值为 ‘u0000’</li>
</ol>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><ul>
<li>Byte</li>
<li>Short</li>
<li>Integer</li>
<li>Long</li>
<li>Float</li>
<li>Double</li>
<li>Boolean</li>
<li>Character</li>
</ul>
<h3 id="包装类和基本数据类型的区别"><a href="#包装类和基本数据类型的区别" class="headerlink" title="包装类和基本数据类型的区别"></a>包装类和基本数据类型的区别</h3><p>包装类不赋值默认为null，基本数据类型有默认值且不为null</p>
<p>基本数据类型存放在JVM中的栈空间中的局部变量表中，包装类属于对象，我们知道几乎所有的对象都存放在堆中，相对于包装类，基本数据类型占用的空间非常小。</p>
<h3 id="包装类中的常量池技术"><a href="#包装类中的常量池技术" class="headerlink" title="包装类中的常量池技术"></a>包装类中的常量池技术</h3><p>Byte，Short，Integer，Long都实现了常量池的技术，并默认创建了[-128~127]的相应类型的缓存，Character创建了[0,127]的缓存数据</p>
<p>Boolean直接返回true或false</p>
<p>例如：</p>
<pre><code class="java">/**
*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。
*/
public static Integer valueOf(int i) &#123;
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
      return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
&#125;
private static class IntegerCache &#123;
    static final int low = -128;
    static final int high;
    static final Integer cache[];
&#125;
</code></pre>
<p>如果超出对应的范围，还是会去创建新的对象，缓存的范围区间大小在性能和资源之间权衡</p>
<p>Float和Double没有实现常量池技术</p>
<pre><code class="java">Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true
Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);// 输出 false
Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false
</code></pre>
<p>所有包装类对象之间的比较，都用equals方法</p>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208092010747.png" alt="img"></p>
<h2 id="为什么要有包装类"><a href="#为什么要有包装类" class="headerlink" title="为什么要有包装类"></a>为什么要有包装类</h2><p>因为Java 本身就是一个面向对象的语言（OOP），对象时Java的灵魂</p>
<p>让基本数据类型具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><pre><code class="java">Integer i = 10;  //装箱
int n = i;   //拆箱
</code></pre>
<p>对应的字节码 为</p>
<pre><code class="JAVA">   L1
    LINENUMBER 8 L1
    ALOAD 0
    BIPUSH 10
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;
   L2
    LINENUMBER 9 L2
    ALOAD 0
    ALOAD 0
    GETFIELD AutoBoxTest.i : Ljava/lang/Integer;
    INVOKEVIRTUAL java/lang/Integer.intValue ()I
    PUTFIELD AutoBoxTest.n : I
    RETURN
</code></pre>
<p>可以看到装箱实际上就是调用了valueOf()的方法</p>
<p>拆箱实际上就是调用了xxxValue()的方法</p>
<h3 id="自动拆箱引发的NPE-NullPointException-问题"><a href="#自动拆箱引发的NPE-NullPointException-问题" class="headerlink" title="自动拆箱引发的NPE(NullPointException)问题"></a>自动拆箱引发的NPE(NullPointException)问题</h3><p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208092016526.png" alt="img"></p>
<p><strong>数据库拆箱结果可能为NUll，因为自动拆箱，用基本数据类型有NEP的风险</strong></p>
<pre><code class="JAVA">public class AutoBoxTest &#123;
    @Test
    void  should_Throw_NullPointerException()&#123;
        long id = getNum();
    &#125;
    public Long getNum()&#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>​	等价于</p>
<pre><code class="JAVA">long id = getBum().longValue;
</code></pre>
<p>因为getNum()为null，用null调用一个方法，报错NEP</p>
<p>此外三目运算符也可能会产生NEP</p>
<pre><code class="JAVA">public class Main &#123;
    public static void main(String[] args) &#123;
        Integer i = null;
        Boolean flag = false;
        System.out.println(flag ? 0 : i);
    &#125;
&#125;
</code></pre>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208092022418.png" alt="img"></p>
<p>此时三木运算符中存在基本数据类型0，会产生自动拆箱的操作，i 被自动拆箱所以产生异常NEP</p>
<p>正确写法如下：</p>
<pre><code class="JAVA">Integer i = null;
Boolean flag = false;
System.out.println(flag ? new Integer(0) : i);// 两者类型一致就不会有拆箱导致的 NPE 问题了
</code></pre>
<p><img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202208092023076.png" alt="img"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/myblog.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" style="color: #ffa2c4">
                面试题
            </a>
        </span>
        
    </div>
    <a href="/myblog.github.io/2022/12/22/Day15/" class="go-post">阅读全文</a>
</div>


            <div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">1</span>
        
        <span>
            <a class="page-num" href="/myblog.github.io/page/2/">2</a>
            
            <a class="page-num" href="/myblog.github.io/page/3">3</a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a class="page-num" href="/myblog.github.io/page/2/">
            <i class="fa-solid fa-caret-right fa-fw"></i>
        </a>
        
    </div>
</div>

        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://blog-picgo1-1312893782.cos.ap-shanghai.myqcloud.com//blog/202207200831813.jpeg" alt="avatar" />
        </div>
        <div class="name">John Doe</div>
        <div class="description">
            <p>world1stCJB</p>

        </div>
        
        
    </div>
</div>

    </div>
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 Hexo
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;John Doe
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/myblog.github.io/js/main.js"></script>
        
    </body>
</html>
